name: mnn_aarch64_static_release
on:
  push:
    tags:
      - '*'
  workflow_dispatch:

jobs:
  setup:
    permissions:
      contents: none
    runs-on: ubuntu-latest
    outputs:
      VERSION: ${{ steps.get_version.outputs.VERSION }}
    steps:
    - name: get-version
      id: get_version
      run: |
        if [[ "${GITHUB_REF}" == refs/tags/* ]]; then
          echo "VERSION=${GITHUB_REF#refs/tags/}" >> $GITHUB_OUTPUT
        else
          echo "VERSION=dev" >> $GITHUB_OUTPUT
        fi

  linux-arm64-static-release:
    needs: [setup]
    runs-on: ubuntu-24.04-arm
    env:
      PACKAGENAME: mnn_${{ needs.setup.outputs.VERSION }}_linux_aarch64_static_tools
    steps:
    - uses: actions/checkout@v4
      with:
        submodules: true
    
    - name: Install dependencies for static build
      run: |
        sudo apt-get update
        sudo apt-get install -y build-essential cmake ninja-build
        # Instalar versões estáticas das dependências
        sudo apt-get install -y libprotobuf-dev:arm64 protobuf-compiler
        sudo apt-get install -y opencl-headers ocl-icd-libopencl1:arm64
        sudo apt-get install -y libjpeg-dev:arm64 libpng-dev:arm64
        # Bibliotecas estáticas do sistema
        sudo apt-get install -y libc6-dev:arm64 libstdc++6:arm64
        sudo apt-get install -y libprotobuf-lite32:arm64 libprotoc32:arm64
    
    - name: Build protobuf statically (if needed)
      run: |
        # Verificar se protobuf estático está disponível
        pkg-config --exists protobuf || {
          echo "Building protobuf statically..."
          wget https://github.com/protocolbuffers/protobuf/releases/download/v21.12/protobuf-all-21.12.tar.gz
          tar -xzf protobuf-all-21.12.tar.gz
          cd protobuf-21.12
          ./configure --enable-static --disable-shared --prefix=/tmp/protobuf-static
          make -j4 && make install
          export PKG_CONFIG_PATH="/tmp/protobuf-static/lib/pkgconfig:$PKG_CONFIG_PATH"
          export PATH="/tmp/protobuf-static/bin:$PATH"
          cd ..
        }
    
    - name: Build MNN with static linking
      run: |
        mkdir build && cd build
        
        # Configurar para linking estático completo
        export LDFLAGS="-static -static-libgcc -static-libstdc++"
        export CXXFLAGS="-static -static-libgcc -static-libstdc++"
        
        cmake .. \
          -DMNN_BUILD_CONVERTER=ON \
          -DMNN_BUILD_TOOLS=ON \
          -DMNN_BUILD_BENCHMARK=ON \
          -DMNN_USE_OPENCL=OFF \
          -DMNN_BUILD_SHARED_LIBS=OFF \
          -DMNN_BUILD_OPENCV=OFF \
          -DMNN_IMGCODECS=OFF \
          -DCMAKE_BUILD_TYPE=Release \
          -DCMAKE_CXX_FLAGS="-static -static-libgcc -static-libstdc++" \
          -DCMAKE_C_FLAGS="-static" \
          -DCMAKE_EXE_LINKER_FLAGS="-static -static-libgcc -static-libstdc++" \
          -DCMAKE_FIND_LIBRARY_SUFFIXES=".a" \
          -DBUILD_SHARED_LIBS=OFF \
          -GNinja
        
        # Build com mais verbosidade para debug
        ninja -j4 -v
    
    - name: Verify static linking
      run: |
        echo "=== Checking for static binaries ==="
        find build -name "MNNConvert" -type f -executable 2>/dev/null | while read file; do
          echo "Checking: $file"
          ldd "$file" 2>&1 | grep -q "not a dynamic executable" && echo "✅ Static binary" || {
            echo "❌ Dynamic dependencies found:"
            ldd "$file" 2>/dev/null || echo "ldd failed"
          }
          file "$file"
          echo "Size: $(du -sh "$file" | cut -f1)"
          echo "---"
        done
        
        echo "=== All executables found ==="
        find build -type f -executable | head -10
    
    - name: Package static tools and libraries
      run: |
        mkdir -p ${{ env.PACKAGENAME }}/{bin,lib,include}
        
        # Copiar ferramentas estáticas
        find build -name "MNNConvert" -type f -executable -exec cp {} ${{ env.PACKAGENAME }}/bin/ \; 2>/dev/null || echo "MNNConvert not found"
        find build -name "MNNDump" -type f -executable -exec cp {} ${{ env.PACKAGENAME }}/bin/ \; 2>/dev/null || echo "MNNDump not found"
        find build -name "benchmark*" -type f -executable -exec cp {} ${{ env.PACKAGENAME }}/bin/benchmark \; 2>/dev/null || echo "benchmark not found"
        find build -name "MNNV2Basic*" -type f -executable -exec cp {} ${{ env.PACKAGENAME }}/bin/ \; 2>/dev/null || echo "MNNV2Basic not found"
        
        # Copiar apenas bibliotecas estáticas
        find build -name "libMNN.a" -type f -exec cp {} ${{ env.PACKAGENAME }}/lib/ \; 2>/dev/null || echo "libMNN.a not found"
        find build -name "libMNN_Express.a" -type f -exec cp {} ${{ env.PACKAGENAME }}/lib/ \; 2>/dev/null || echo "libMNN_Express.a not found"
        find build -name "libmnncore.a" -type f -exec cp {} ${{ env.PACKAGENAME }}/lib/ \; 2>/dev/null || echo "libmnncore.a not found"
        
        # Copiar headers
        cp -r include/MNN ${{ env.PACKAGENAME }}/include/ 2>/dev/null || echo "Headers not copied"
        
        # Criar script de verificação melhorado
        cat > ${{ env.PACKAGENAME }}/verify_static.sh << 'EOF'
        #!/bin/bash
        echo "=== MNN Static Tools Verification ==="
        echo "Package: $(basename "$(pwd)")"
        echo "Date: $(date)"
        echo ""
        
        echo "=== Available Tools ==="
        ls -la bin/ 2>/dev/null || echo "No bin directory found"
        echo ""
        
        echo "=== Static Libraries ==="
        ls -la lib/ 2>/dev/null || echo "No lib directory found"
        echo ""
        
        echo "=== Checking Static Linking ==="
        for tool in bin/*; do
          if [[ -x "$tool" ]]; then
            echo "Tool: $(basename "$tool")"
            echo "  Size: $(du -sh "$tool" | cut -f1)"
            echo "  Type: $(file "$tool" | cut -d: -f2)"
            echo "  Dependencies:"
            if ldd "$tool" 2>&1 | grep -q "not a dynamic executable"; then
              echo "    ✅ Statically linked"
            else
              echo "    ❌ Has dynamic dependencies:"
              ldd "$tool" 2>/dev/null | sed 's/^/      /'
            fi
            echo ""
        
            # Teste básico de funcionalidade
            if [[ "$(basename "$tool")" == "MNNConvert" ]]; then
              echo "  Testing MNNConvert:"
              if "$tool" --help >/dev/null 2>&1; then
                echo "    ✅ MNNConvert responds to --help"
              else
                echo "    ❓ Testing version or usage..."
                "$tool" 2>&1 | head -3 | sed 's/^/      /'
              fi
              echo ""
            fi
          fi
        done
        
        echo "=== System Info ==="
        echo "Architecture: $(uname -m)"
        echo "Kernel: $(uname -r)"
        echo "OS: $(cat /etc/os-release | grep PRETTY_NAME | cut -d= -f2 | tr -d '"')"
        EOF
        chmod +x ${{ env.PACKAGENAME }}/verify_static.sh
        
        # Criar README
        cat > ${{ env.PACKAGENAME }}/README.md << 'EOF'
        # MNN Static Tools for ARM64 Linux
        
        This package contains statically linked MNN tools and libraries for ARM64 Linux.
        
        ## Contents
        
        - `bin/MNNConvert` - Convert ONNX models to MNN format
        - `bin/benchmark` - Performance benchmarking tool
        - `bin/MNNV2Basic.out` - Basic inference example
        - `lib/` - Static libraries for development
        - `include/` - Header files for C++ development
        
        ## Usage
        
        ### Convert ONNX to MNN
        ```
        ./bin/MNNConvert -f ONNX --modelFile model.onnx --MNNModel model.mnn --bizCode MNN
        ```
        
        ### Verify Installation
        ```
        ./verify_static.sh
        ```
        
        ## Notes
        
        - All binaries are statically linked and should work on any ARM64 Linux system
        - No external dependencies required
        - Built with release optimizations
        
        EOF
        
        # Verificar conteúdo final
        echo "=== Package Contents ==="
        find ${{ env.PACKAGENAME }} -type f | sort
        echo ""
        echo "=== File Sizes ==="
        du -sh ${{ env.PACKAGENAME }}/*
    
    - name: Test static binaries
      run: |
        cd ${{ env.PACKAGENAME }}
        echo "=== Running verification script ==="
        ./verify_static.sh
    
    - name: Create package
      run: |
        # Usar tar.xz para máxima compressão
        tar -cJf ${{ env.PACKAGENAME }}.tar.xz ${{ env.PACKAGENAME }}
        
        echo "=== Final Package Info ==="
        ls -lh ${{ env.PACKAGENAME }}.tar.xz
        echo ""
        echo "Package size: $(du -sh ${{ env.PACKAGENAME }}.tar.xz | cut -f1)"
        echo "Uncompressed size: $(du -sh ${{ env.PACKAGENAME }} | cut -f1)"
    
    - name: Upload artifact
      uses: actions/upload-artifact@v4
      with:
        name: artifact-${{ env.PACKAGENAME }}
        path: ${{ env.PACKAGENAME }}.tar.xz
        retention-days: 30

  upload-release:
    name: upload_to_release
    needs: [linux-arm64-static-release]
    runs-on: ubuntu-latest
    if: startsWith(github.ref, 'refs/tags/')
    steps:
    - uses: actions/download-artifact@v4
      with:
        pattern: artifact-*
        path: assert
        merge-multiple: true

    - name: Show files to upload
      run: |
        echo "=== Files to upload ==="
        ls -la assert/
        echo ""
        for file in assert/*; do
          echo "File: $(basename "$file")"
          echo "Size: $(du -sh "$file" | cut -f1)"
          echo "---"
        done

    - name: Upload to GitHub Release
      uses: xresloader/upload-to-github-release@v1
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
      with:
        file: assert/*.tar.xz
        tags: true
        draft: true
        overwrite: true
        verbose: true
